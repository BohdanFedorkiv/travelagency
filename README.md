@Data - це зручна анотація ярликів, 
яка поєднує в собі функції @ToString, @EqualsAndHashCode, @Getter / @Setter
і @RequiredArgsConstructor для всіх нефінальних полів 
та відповідні реалізації.
@Data - це як мати неявні анотації @Getter, @Setter, @ToString, 
@EqualsAndHashCode і @RequiredArgsConstructor у класі 
(за винятком того, що жоден конструктор не буде створений, 
якщо вже існують явно написані конструктори). 
Однак параметри цих анотацій (наприклад, callSuper, includeFieldNames 
та exclude) не можуть бути встановлені за допомогою @Data. 
Якщо вам потрібно встановити значення, 
що не за замовчуванням, для будь-якого з цих параметрів, 
просто додайте ці анотації явно

Анотація @Builder створює складні API будівельника для ваших класів.
@Builder дозволяє вам автоматично виробляти код, необхідний для того, 
щоб ваш клас міг бути інстальованим з таким кодом, як:
Person.builder().name("Adam Savage").city("San Francisco")
.job("Mythbusters").job("Unchained Reaction").build();
@Builder може бути розміщений у класі, у конструкторі чи методі. 

@AllArgsConstructor генерує конструктор з 1 параметром для кожного поля 
у вашому класі. Поля, позначені @NonNull, призводять до нульових перевірок 
цих параметрів.

@NoArgsConstructor згенерує конструктор без параметрів. 
Якщо це неможливо (через кінцеві поля), замість цього приведе 
до помилки компілятора, якщо не використовується 
@NoArgsConstructor (force = true), тоді всі кінцеві поля 
ініціалізуються 0 / false / null. Для полів з обмеженнями, 
таких як поля @NonNull, перевірка не генерується, тому майте на увазі, 
що ці обмеження, як правило, не виконуються, поки ці поля не будуть 
належним чином ініціалізовані пізніше.

fetch = FetchType.EAGER - неліниве завантаження даних. Тобто завантажуються
всі поля, а не тільки ті, які підходять під зовншній ключ

Аннотация @Repository - это маркер для любого класса, 
который выполняет роль или стереотип репозитория 
(также известный как объект доступа к данным или DAO). 
Одним из применений этого маркера является автоматический перевод исключений,
как описано в разделе Перевод исключений

Сеанс (сессия) – соединение между клиентом и сервером, 
устанавливаемое на определенное время, за которое клиент может 
отправить на сервер сколько угодно запросов. Сеанс устанавливается 
непосредственно между клиентом и Web-сервером. Каждый клиент устанавливает 
с сервером свой собственный сеанс.
Сеансы используются для обеспечения хранения данных во время 
нескольких запросов Web-страницы или на обработку информации, 
введенной в пользовательскую форму в результате нескольких HTTP-соединений.

SessionFactory) – неизменяемый потокобезопасный объект 
с компилированным маппингом для одной базы данных. 
Необходимо инициализировать SessionFactory всего один раз. 
Экземпляр SessionFactory используется для получения объектов Session, 
которые используются для операций с базами данных.

Транзакцию дают нам возможность контролировать когда и где 
сохранять изменения в БД. Благодаря этому мы, например, можем объединить 
группу SQL – запросов в одну логическую группу и, если один из запросов 
не пройдёт – мы отменяем всю транзакцию.
После того, как мы выполнили необходимые нам изменения, 
мы должны вызвать метод commit() 

